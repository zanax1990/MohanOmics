import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from scipy import stats
from sklearn.impute import KNNImputer
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from gprofiler import GProfiler

# -----------------------------------------------------------------------------
# PAGE CONFIGURATION
# -----------------------------------------------------------------------------
st.set_page_config(
    page_title="MohanOmics Analyzer",
    page_icon="ðŸ§¬",
    layout="wide",
    initial_sidebar_state="expanded"
)

# -----------------------------------------------------------------------------
# CUSTOM CSS
# -----------------------------------------------------------------------------
st.markdown("""
    <style>
    .block-container {padding-top: 1rem;}
    h1 {color: #0e1117;}
    h2 {color: #262730;}
    .stButton>button {width: 100%; border-radius: 5px; height: 3em; font-weight: bold;}
    </style>
""", unsafe_allow_html=True)

# -----------------------------------------------------------------------------
# HELPERS
# -----------------------------------------------------------------------------
def run_vectorized_ttest(df, group_a_cols, group_b_cols):
    """
    Vectorized Welch's t-test. Matches R behavior for 0-variance groups.
    """
    data_a = df[group_a_cols].values
    data_b = df[group_b_cols].values
    
    # Calculate Variance
    var_a = np.nanvar(data_a, axis=1, ddof=1)
    var_b = np.nanvar(data_b, axis=1, ddof=1)
    
    # Run T-Test
    # equal_var=False (Welch's) works fine even if ONE group has 0 variance.
    t_stat, p_val = stats.ttest_ind(data_b, data_a, axis=1, equal_var=False, nan_policy='omit')
    
    # FIX v3.5: Only force P=1 if BOTH groups have 0 variance (completely constant)
    # This restores the "Presence/Absence" hits that v3.4 killed.
    mask_both_zero = (var_a == 0) & (var_b == 0)
    p_val[mask_both_zero] = 1.0
    
    # Also handle NaNs generated by scipy (when data is insufficient)
    p_val = np.nan_to_num(p_val, nan=1.0)
    
    # Rounding to match R precision
    p_val = np.round(p_val, 6)
    
    # Calculate Log2FC
    mean_a = np.nanmean(data_a, axis=1)
    mean_b = np.nanmean(data_b, axis=1)
    log2fc = mean_b - mean_a 
    log2fc = np.round(log2fc, 6)
    
    return p_val, log2fc

@st.cache_data(ttl=3600)
def run_pathway_enrichment(gene_list, organism='mmusculus'):
    if not gene_list: return None
    gp = GProfiler(return_dataframe=True)
    try:
        results = gp.profile(organism=organism, query=gene_list, sources=["GO:BP", "KEGG"])
        if results.empty: return None
        results = results[['source', 'native', 'name', 'p_value', 'intersection_size']]
        results = results.sort_values('p_value').head(20)
        return results
    except: return None

# -----------------------------------------------------------------------------
# SIDEBAR
# -----------------------------------------------------------------------------
st.sidebar.title("ðŸ§¬ MohanOmics")
st.sidebar.info("v3.5 - Golden Match")
st.sidebar.markdown("---")
st.sidebar.subheader("1. Data Import")
uploaded_file = st.sidebar.file_uploader("Upload Report (.csv)", type=["csv", "txt"])
DEFAULT_PATH = r"D:\Project\Mohan\Jen\Software\20250728_112202_20250728_RMohan_mouse_6lysates_HT_DIApasef_Report.csv"

# -----------------------------------------------------------------------------
# MAIN LOGIC
# -----------------------------------------------------------------------------
st.title("ðŸ§¬ MohanOmics: Advanced Proteomics Suite")
st.markdown("### Interactive AI-Driven Analysis & Pathway Discovery")

df = None
if uploaded_file is not None:
    try:
        df = pd.read_csv(uploaded_file)
        if df.shape[1] < 2: uploaded_file.seek(0); df = pd.read_csv(uploaded_file, sep='\t')
    except: st.error("Could not read file.")
else:
    try: df = pd.read_csv(DEFAULT_PATH); st.success("Loaded default local dataset (Dev Mode).")
    except: st.info("Waiting for file upload...")

if df is not None:
    # --- STEP 1: QC ---
    st.sidebar.subheader("2. Quality Control (QC)")
    total_proteins = len(df)
    if 'PG.QValue (Run-Wise)' in df.columns:
        thresh = st.sidebar.slider("Max Q-Value Filter", 0.0, 0.05, 0.01, 0.001)
        df = df[df['PG.QValue (Run-Wise)'] <= thresh]
    if 'PG.IsSingleHit' in df.columns:
        if st.sidebar.checkbox("Remove Single Hits", value=True): df = df[df['PG.IsSingleHit'] == False]
    filtered_proteins = len(df)

    try:
        df['SampleName'] = df['R.Condition'] + "_" + df['R.Replicate'].astype(str)
        df_pivot = df.pivot_table(
            index=['PG.ProteinAccessions', 'PG.Genes', 'PG.ProteinDescriptions'], 
            columns='SampleName', values='PG.Quantity', aggfunc='first'
        )
        protein_meta = df_pivot.index.to_frame().reset_index(drop=True)
        expression_data = df_pivot.values
        sample_names = df_pivot.columns.tolist()

        tab1, tab2, tab3, tab4, tab5 = st.tabs(["ðŸ“Š QC & Overview", "ðŸ¤– AI Imputation", "ðŸ” PCA & Heatmap", "ðŸŒ‹ Differential Analysis", "ðŸ§¬ Biological Pathways"])

        with tab1:
            c1, c2, c3 = st.columns(3)
            c1.metric("Total", total_proteins); c2.metric("High Confidence", filtered_proteins); c3.metric("Samples", len(sample_names))
            st.dataframe(df_pivot.head())

        with tab2:
            col_opts, col_viz = st.columns([1, 2])
            with col_opts:
                st.markdown("**1. Log2 Transformation**")
                with np.errstate(divide='ignore'): data_log = np.log2(expression_data); data_log[np.isinf(data_log)] = np.nan
                imp_method = st.radio("Method:", ["âœ¨ AI-based (KNN)", "Min Value", "Zero Fill"])
            
            df_imputed = pd.DataFrame(data_log, columns=sample_names, index=df_pivot.index)
            if imp_method == "âœ¨ AI-based (KNN)":
                with st.spinner("Running AI Model..."):
                    imputer = KNNImputer(n_neighbors=3)
                    df_final = pd.DataFrame(imputer.fit_transform(df_imputed), columns=sample_names, index=df_pivot.index)
                    st.success("AI Imputation Complete.")
            elif imp_method == "Min Value":
                df_final = df_imputed.fillna(np.nanmin(data_log)); st.warning("Imputed with Min.")
            else:
                df_final = df_imputed.fillna(0); st.warning("Imputed with Zero.")

            with col_viz:
                fig_hist = go.Figure()
                fig_hist.add_trace(go.Histogram(x=data_log.flatten(), name='Original', opacity=0.75, marker_color='gray'))
                fig_hist.add_trace(go.Histogram(x=df_final.values.flatten(), name='Imputed', opacity=0.5, marker_color='blue'))
                fig_hist.update_layout(barmode='overlay', title="Data Distribution Impact", height=300, margin=dict(t=30,b=0))
                st.plotly_chart(fig_hist, use_container_width=True)

        with tab3:
            pca_col, heat_col = st.columns(2)
            with pca_col:
                pca_input = df_final.T
                pca = PCA(n_components=2)
                components = pca.fit_transform(pca_input)
                pca_df = pd.DataFrame(components, columns=['PC1', 'PC2'])
                pca_df['Sample'] = pca_input.index
                pca_df['Group'] = pca_df['Sample'].apply(lambda x: x.split('_')[0])
                fig_pca = px.scatter(pca_df, x='PC1', y='PC2', color='Group', text='Sample', title=f"PCA (Exp: {pca.explained_variance_ratio_[0]*100:.1f}%)")
                fig_pca.update_traces(textposition='top center'); st.plotly_chart(fig_pca, use_container_width=True)
            with heat_col:
                fig_corr = px.imshow(df_final.corr(), text_auto=True, aspect="auto", color_continuous_scale='RdBu_r', title="Correlation Matrix")
                st.plotly_chart(fig_corr, use_container_width=True)

        with tab4:
            conditions = list(set([s.split('_')[0] for s in sample_names]))
            c1, c2 = st.columns(2)
            cond_a = c1.selectbox("Group A (Test)", conditions, index=0)
            cond_b = c2.selectbox("Group B (Control)", conditions, index=1 if len(conditions)>1 else 0)
            cols_a = [c for c in sample_names if c.startswith(cond_a)]; cols_b = [c for c in sample_names if c.startswith(cond_b)]
            
            p_vals, log2fcs = run_vectorized_ttest(df_final, cols_a, cols_b)
            
            df_res = protein_meta.copy()
            df_res['Log2FC'] = log2fcs; df_res['P_Value'] = p_vals; df_res['NegLogP'] = -np.log10(p_vals)
            df_res['NegLogP'] = df_res['NegLogP'].replace([np.inf, -np.inf], 50)
            
            fc_cut = st.slider("Log2FC Cutoff", 0.0, 4.0, 1.0, 0.1)
            p_cut = st.slider("P-Value Cutoff", 0.0, 0.1, 0.05, 0.001)
            
            conditions_list = [(df_res['P_Value'] < p_cut) & (df_res['Log2FC'] > fc_cut), (df_res['P_Value'] < p_cut) & (df_res['Log2FC'] < -fc_cut)]
            df_res['Category'] = np.select(conditions_list, ['Upregulated', 'Downregulated'], default='Not Significant')
            
            st.session_state['stats_result'] = df_res 
            st.session_state['comp_name'] = f"{cond_a}_vs_{cond_b}"

            fig_vol = px.scatter(df_res, x='Log2FC', y='NegLogP', color='Category', hover_data=['PG.Genes', 'PG.ProteinDescriptions'], color_discrete_map={"Upregulated": "#E63946", "Downregulated": "#457B9D", "Not Significant": "#D3D3D3"}, title=f"Volcano Plot: {cond_a} vs {cond_b}", opacity=0.8)
            fig_vol.add_hline(y=-np.log10(p_cut), line_dash="dash"); fig_vol.add_vline(x=fc_cut, line_dash="dash"); fig_vol.add_vline(x=-fc_cut, line_dash="dash")
            st.plotly_chart(fig_vol, use_container_width=True)
            
            st.markdown("### ðŸ† Top Significant Candidates")
            sig_df = df_res[df_res['Category'] != 'Not Significant'].sort_values('P_Value')
            st.write(f"Found **{len(sig_df)}** significant proteins.")
            st.dataframe(sig_df[['PG.Genes', 'Log2FC', 'P_Value', 'Category']].style.format({"Log2FC": "{:.2f}", "P_Value": "{:.2e}"}), use_container_width=True)
            csv = sig_df.to_csv(index=False).encode('utf-8')
            st.download_button(label="ðŸ“¥ Download CSV", data=csv, file_name='Significant_Proteins.csv', mime='text/csv')

        with tab5:
            st.subheader("ðŸ¤– Automated Biological Interpretation")
            if 'stats_result' in st.session_state:
                res_df = st.session_state['stats_result']
                up_genes = res_df[res_df['Category'] == 'Upregulated']['PG.Genes'].dropna().unique().tolist()
                down_genes = res_df[res_df['Category'] == 'Downregulated']['PG.Genes'].dropna().unique().tolist()
                col_up, col_down = st.columns(2)
                with col_up:
                    st.markdown(f"### â¬†ï¸ Upregulated ({len(up_genes)})")
                    if len(up_genes) > 5:
                        with st.spinner("Querying DB..."): path_up = run_pathway_enrichment(up_genes) 
                        if path_up is not None:
                            path_up['neg_log_p'] = -np.log10(path_up['p_value']) 
                            fig_up = px.bar(path_up, x='neg_log_p', y='name', orientation='h', color='source', title=f"Top Enriched Pathways", height=400)
                            fig_up.update_layout(yaxis={'categoryorder':'total ascending'}); st.plotly_chart(fig_up, use_container_width=True)
                        else: st.info("No significant pathways.")
                    else: st.warning("Need >5 genes.")
                with col_down:
                    st.markdown(f"### â¬‡ï¸ Downregulated ({len(down_genes)})")
                    if len(down_genes) > 5:
                        with st.spinner("Querying DB..."): path_down = run_pathway_enrichment(down_genes)
                        if path_down is not None:
                            path_down['neg_log_p'] = -np.log10(path_down['p_value'])
                            fig_down = px.bar(path_down, x='neg_log_p', y='name', orientation='h', color='source', title=f"Top Enriched Pathways", height=400)
                            fig_down.update_layout(yaxis={'categoryorder':'total ascending'}); st.plotly_chart(fig_down, use_container_width=True)
                        else: st.info("No significant pathways.")
                    else: st.warning("Need >5 genes.")
            else: st.error("Go to Tab 4 first.")

    except Exception as e:
        st.error(f"Error: {e}")
